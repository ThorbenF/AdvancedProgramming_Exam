<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BST_Doxygen: BST&lt; key, value, comparator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BST_Doxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_b_s_t-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BST&lt; key, value, comparator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_b_s_t_8h_source.html">BST.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t_1_1_const_iterator.html">ConstIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_b_s_t_1_1_const_iterator.html" title="ConstIterator is using the functionality of the Iterator class, but is preventing the accessed elemen...">ConstIterator</a> is using the functionality of the <a class="el" href="class_b_s_t_1_1_iterator.html" title="Iterator uses struct node of BST() class.">Iterator</a> class, but is preventing the accessed elements to be manipulated by returning <a class="el" href="class_b_s_t_1_1_const_iterator.html#ab5ddd11eba4590a965fc5052f8c4bbaa">operator*() const</a>.  <a href="class_b_s_t_1_1_const_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t_1_1_iterator.html">Iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_b_s_t_1_1_iterator.html" title="Iterator uses struct node of BST() class.">Iterator</a> uses struct node of <a class="el" href="class_b_s_t.html#a88de1603a81df3c011417d5712370a40" title="Each BST class is constructed with a smart pointer to the root node and a comparison functor.">BST()</a> class. <br  />
  <a href="class_b_s_t_1_1_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a88de1603a81df3c011417d5712370a40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a88de1603a81df3c011417d5712370a40">BST</a> ()</td></tr>
<tr class="memdesc:a88de1603a81df3c011417d5712370a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each <a class="el" href="class_b_s_t.html">BST</a> class is constructed with a smart pointer to the root node and a comparison functor.  <a href="class_b_s_t.html#a88de1603a81df3c011417d5712370a40">More...</a><br /></td></tr>
<tr class="separator:a88de1603a81df3c011417d5712370a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee31904f12c72b6b748b46f7db78521e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_t_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#aee31904f12c72b6b748b46f7db78521e">begin</a> ()</td></tr>
<tr class="memdesc:aee31904f12c72b6b748b46f7db78521e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_b_s_t_1_1_iterator.html" title="Iterator uses struct node of BST() class.">Iterator</a> to the node with lowest key.  <a href="class_b_s_t.html#aee31904f12c72b6b748b46f7db78521e">More...</a><br /></td></tr>
<tr class="separator:aee31904f12c72b6b748b46f7db78521e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad831fe01fa6994bcaa422b078bfc56b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_t_1_1_iterator.html">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#ad831fe01fa6994bcaa422b078bfc56b1">end</a> ()</td></tr>
<tr class="memdesc:ad831fe01fa6994bcaa422b078bfc56b1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_b_s_t_1_1_iterator.html" title="Iterator uses struct node of BST() class.">Iterator</a> Returns nullptr.  <a href="class_b_s_t.html#ad831fe01fa6994bcaa422b078bfc56b1">More...</a><br /></td></tr>
<tr class="separator:ad831fe01fa6994bcaa422b078bfc56b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b593873a9d724bc9fa5e9de17c4fb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_t_1_1_const_iterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#aa1b593873a9d724bc9fa5e9de17c4fb8">cbegin</a> () const</td></tr>
<tr class="memdesc:aa1b593873a9d724bc9fa5e9de17c4fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_b_s_t_1_1_const_iterator.html" title="ConstIterator is using the functionality of the Iterator class, but is preventing the accessed elemen...">ConstIterator</a> to the node with lowest key.  <a href="class_b_s_t.html#aa1b593873a9d724bc9fa5e9de17c4fb8">More...</a><br /></td></tr>
<tr class="separator:aa1b593873a9d724bc9fa5e9de17c4fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc09f735bc42e8183492837a0f00620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_t_1_1_const_iterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a8dc09f735bc42e8183492837a0f00620">cend</a> () const</td></tr>
<tr class="memdesc:a8dc09f735bc42e8183492837a0f00620"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_b_s_t_1_1_const_iterator.html" title="ConstIterator is using the functionality of the Iterator class, but is preventing the accessed elemen...">ConstIterator</a> Returns nullptr.  <a href="class_b_s_t.html#a8dc09f735bc42e8183492837a0f00620">More...</a><br /></td></tr>
<tr class="separator:a8dc09f735bc42e8183492837a0f00620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538f996f02dc7057947d2d527d25a580"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a538f996f02dc7057947d2d527d25a580">insert</a> (const key k, value v)</td></tr>
<tr class="memdesc:a538f996f02dc7057947d2d527d25a580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Making use of the comparison functor allows adding a pair of key and value as soon as a nullptr is encountered in the next smart pointer of the current node.  <a href="class_b_s_t.html#a538f996f02dc7057947d2d527d25a580">More...</a><br /></td></tr>
<tr class="separator:a538f996f02dc7057947d2d527d25a580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568add02af128e84894274c14dff723c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a568add02af128e84894274c14dff723c">clear</a> ()</td></tr>
<tr class="memdesc:a568add02af128e84894274c14dff723c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the root-node back to nullptr.  <a href="class_b_s_t.html#a568add02af128e84894274c14dff723c">More...</a><br /></td></tr>
<tr class="separator:a568add02af128e84894274c14dff723c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2645be2b51a9f23dd6a7d413d37118d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a2645be2b51a9f23dd6a7d413d37118d0">balance</a> ()</td></tr>
<tr class="memdesc:a2645be2b51a9f23dd6a7d413d37118d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not in-place balancing of the tree in a recursive manner.  <a href="class_b_s_t.html#a2645be2b51a9f23dd6a7d413d37118d0">More...</a><br /></td></tr>
<tr class="separator:a2645be2b51a9f23dd6a7d413d37118d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981561762ee1793511d351735c1b60f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_t_1_1_const_iterator.html">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a981561762ee1793511d351735c1b60f3">find</a> (const key k) const</td></tr>
<tr class="memdesc:a981561762ee1793511d351735c1b60f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for a given key.  <a href="class_b_s_t.html#a981561762ee1793511d351735c1b60f3">More...</a><br /></td></tr>
<tr class="separator:a981561762ee1793511d351735c1b60f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71484110f50915eb23a1d6b5dccd753f"><td class="memItemLeft" align="right" valign="top">value &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a71484110f50915eb23a1d6b5dccd753f">operator[]</a> (const key &amp;k)</td></tr>
<tr class="memdesc:a71484110f50915eb23a1d6b5dccd753f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator allowing value access via key.  <a href="class_b_s_t.html#a71484110f50915eb23a1d6b5dccd753f">More...</a><br /></td></tr>
<tr class="separator:a71484110f50915eb23a1d6b5dccd753f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309e1fe7dda03eff31910ae86b574fa5"><td class="memItemLeft" align="right" valign="top">const value &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a309e1fe7dda03eff31910ae86b574fa5">operator[]</a> (const key &amp;k) const</td></tr>
<tr class="memdesc:a309e1fe7dda03eff31910ae86b574fa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const operator allowing value access via key.  <a href="class_b_s_t.html#a309e1fe7dda03eff31910ae86b574fa5">More...</a><br /></td></tr>
<tr class="separator:a309e1fe7dda03eff31910ae86b574fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed87c6c0a8fa750345ff14cb548a2636"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#aed87c6c0a8fa750345ff14cb548a2636">BST</a> (const <a class="el" href="class_b_s_t.html">BST</a> &amp;bst_rhs)</td></tr>
<tr class="memdesc:aed87c6c0a8fa750345ff14cb548a2636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor which constructs a deepcopy with new root-node following the original node structure in a recursive manner and inserting new nodes with the same std::pair as the original.  <a href="class_b_s_t.html#aed87c6c0a8fa750345ff14cb548a2636">More...</a><br /></td></tr>
<tr class="separator:aed87c6c0a8fa750345ff14cb548a2636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d840cd54ab6211c05c9d1b686ab5a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_t.html">BST</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a51d840cd54ab6211c05c9d1b686ab5a4">operator=</a> (const <a class="el" href="class_b_s_t.html">BST</a> &amp;bst_rhs)</td></tr>
<tr class="memdesc:a51d840cd54ab6211c05c9d1b686ab5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment.  <a href="class_b_s_t.html#a51d840cd54ab6211c05c9d1b686ab5a4">More...</a><br /></td></tr>
<tr class="separator:a51d840cd54ab6211c05c9d1b686ab5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfb59cd0cf20a974b13acd609cf91f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a2cfb59cd0cf20a974b13acd609cf91f4">BST</a> (<a class="el" href="class_b_s_t.html">BST</a> &amp;&amp;bst_rhs)</td></tr>
<tr class="memdesc:a2cfb59cd0cf20a974b13acd609cf91f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor which allows that the ownership of the root-node is transferred to the lvalue.  <a href="class_b_s_t.html#a2cfb59cd0cf20a974b13acd609cf91f4">More...</a><br /></td></tr>
<tr class="separator:a2cfb59cd0cf20a974b13acd609cf91f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc62eff481fddb7ed8511acf783502a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_b_s_t.html">BST</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#abc62eff481fddb7ed8511acf783502a1">operator=</a> (<a class="el" href="class_b_s_t.html">BST</a> &amp;&amp;bst_rhs)</td></tr>
<tr class="memdesc:abc62eff481fddb7ed8511acf783502a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <a href="class_b_s_t.html#abc62eff481fddb7ed8511acf783502a1">More...</a><br /></td></tr>
<tr class="separator:abc62eff481fddb7ed8511acf783502a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ff8ae550b68b2ad9c32585698e5a20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_b_s_t.html#a26ff8ae550b68b2ad9c32585698e5a20">~BST</a> ()=default</td></tr>
<tr class="memdesc:a26ff8ae550b68b2ad9c32585698e5a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="class_b_s_t.html#a26ff8ae550b68b2ad9c32585698e5a20">More...</a><br /></td></tr>
<tr class="separator:a26ff8ae550b68b2ad9c32585698e5a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class key, class value, class comparator = decltype(&amp; Functor&lt;const key,value&gt;)&gt;<br />
class BST&lt; key, value, comparator &gt;</h3>

<p>The <a class="el" href="class_b_s_t.html">BST</a> class is templated on the type of the const key and the type of the value associated with it allowing for variability in input data and the Functor which template type is derived via decltype(). Nodes are realised as nested struct containing data, smart pointers to the next left and right node as well as a pointer to the local root. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a88de1603a81df3c011417d5712370a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88de1603a81df3c011417d5712370a40">&#9670;&nbsp;</a></span>BST() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key, class value, class comparator = decltype(&amp; Functor&lt;const key,value&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::<a class="el" href="class_b_s_t.html">BST</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Each <a class="el" href="class_b_s_t.html">BST</a> class is constructed with a smart pointer to the root node and a comparison functor. </p>

</div>
</div>
<a id="aed87c6c0a8fa750345ff14cb548a2636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed87c6c0a8fa750345ff14cb548a2636">&#9670;&nbsp;</a></span>BST() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key , class value , class comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::<a class="el" href="class_b_s_t.html">BST</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt; &amp;&#160;</td>
          <td class="paramname"><em>bst_rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor which constructs a deepcopy with new root-node following the original node structure in a recursive manner and inserting new nodes with the same std::pair as the original. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bst_rhs</td><td><a class="el" href="class_b_s_t.html">BST</a> object to copy from.</td></tr>
  </table>
  </dd>
</dl>
<p>a root-node and a functor are initialised. The private member function deepcopy_recursive(), which is taking a reference to the current node of the original tree, is used to build a new tree with the same components as the original by using <a class="el" href="class_b_s_t.html#a538f996f02dc7057947d2d527d25a580" title="Making use of the comparison functor allows adding a pair of key and value as soon as a nullptr is en...">insert()</a>. First the entire left tree side is copied recursively until a nullptr is encountered in rhs tree and then the same is repeated recursively for the right half of the tree. </p>

</div>
</div>
<a id="a2cfb59cd0cf20a974b13acd609cf91f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfb59cd0cf20a974b13acd609cf91f4">&#9670;&nbsp;</a></span>BST() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key , class value , class comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::<a class="el" href="class_b_s_t.html">BST</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>bst_rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor which allows that the ownership of the root-node is transferred to the lvalue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bst_rhs</td><td><a class="el" href="class_b_s_t.html">BST</a> object to acquire ownership from.</td></tr>
  </table>
  </dd>
</dl>
<p>Takes rvalue reference &amp;&amp; and uses std::move() to obtain ownership over the rhs root-node. </p>

</div>
</div>
<a id="a26ff8ae550b68b2ad9c32585698e5a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ff8ae550b68b2ad9c32585698e5a20">&#9670;&nbsp;</a></span>~BST()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key, class value, class comparator = decltype(&amp; Functor&lt;const key,value&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::~<a class="el" href="class_b_s_t.html">BST</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2645be2b51a9f23dd6a7d413d37118d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2645be2b51a9f23dd6a7d413d37118d0">&#9670;&nbsp;</a></span>balance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key , class value , class comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::balance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not in-place balancing of the tree in a recursive manner. </p>
<p>Upon calling the function stores all std:pairs contained in the tree inside a std::vector in ascending order according to key. The tree is set to empty via <a class="el" href="class_b_s_t.html#a568add02af128e84894274c14dff723c" title="Resets the root-node back to nullptr.">clear()</a> and rebuild in a recursive manner using the private member function balance_recursive(std::vector&lt;std::pair&lt;const key, value&gt; &gt;&amp; vec, std::size_t start, std::size_t end). This function recursively determines a median and inserts its data-pair back into the tree via <a class="el" href="class_b_s_t.html#a538f996f02dc7057947d2d527d25a580" title="Making use of the comparison functor allows adding a pair of key and value as soon as a nullptr is en...">insert()</a>. Initially the entire left side of the tree is rebuild with the call to balance_recursive(). As soon as this half of the vector is down to a single data-pair the same procedure is carried out for the right side of the vector. </p>

</div>
</div>
<a id="aee31904f12c72b6b748b46f7db78521e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee31904f12c72b6b748b46f7db78521e">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key , class value , class comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::<a class="el" href="class_b_s_t_1_1_iterator.html">Iterator</a> <a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_b_s_t_1_1_iterator.html" title="Iterator uses struct node of BST() class.">Iterator</a> to the node with lowest key. </p>

</div>
</div>
<a id="aa1b593873a9d724bc9fa5e9de17c4fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1b593873a9d724bc9fa5e9de17c4fb8">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key , class value , class comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::<a class="el" href="class_b_s_t_1_1_const_iterator.html">ConstIterator</a> <a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_b_s_t_1_1_const_iterator.html" title="ConstIterator is using the functionality of the Iterator class, but is preventing the accessed elemen...">ConstIterator</a> to the node with lowest key. </p>

</div>
</div>
<a id="a8dc09f735bc42e8183492837a0f00620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc09f735bc42e8183492837a0f00620">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key, class value, class comparator = decltype(&amp; Functor&lt;const key,value&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t_1_1_const_iterator.html">ConstIterator</a> <a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_b_s_t_1_1_const_iterator.html" title="ConstIterator is using the functionality of the Iterator class, but is preventing the accessed elemen...">ConstIterator</a> Returns nullptr. </p>

</div>
</div>
<a id="a568add02af128e84894274c14dff723c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568add02af128e84894274c14dff723c">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key , class value , class comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the root-node back to nullptr. </p>

</div>
</div>
<a id="ad831fe01fa6994bcaa422b078bfc56b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad831fe01fa6994bcaa422b078bfc56b1">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key, class value, class comparator = decltype(&amp; Functor&lt;const key,value&gt;)&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t_1_1_iterator.html">Iterator</a> <a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_b_s_t_1_1_iterator.html" title="Iterator uses struct node of BST() class.">Iterator</a> Returns nullptr. </p>

</div>
</div>
<a id="a981561762ee1793511d351735c1b60f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981561762ee1793511d351735c1b60f3">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key , class value , class comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::<a class="el" href="class_b_s_t_1_1_const_iterator.html">ConstIterator</a> <a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const key&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for a given key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>target key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname"><a class="el" href="class_b_s_t_1_1_const_iterator.html" title="ConstIterator is using the functionality of the Iterator class, but is preventing the accessed elemen...">ConstIterator</a></td><td>to the corresponding node.</td></tr>
  </table>
  </dd>
</dl>
<p>The search starts with a temporary raw pointer to the root-node and continues until either the target k is found and returned as <a class="el" href="class_b_s_t_1_1_const_iterator.html" title="ConstIterator is using the functionality of the Iterator class, but is preventing the accessed elemen...">ConstIterator</a> to the corresponding nodes or a nullptr is met and returned. </p>

</div>
</div>
<a id="a538f996f02dc7057947d2d527d25a580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538f996f02dc7057947d2d527d25a580">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key , class value , class comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const key&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Making use of the comparison functor allows adding a pair of key and value as soon as a nullptr is encountered in the next smart pointer of the current node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k,v</td><td>arbitrary input key and value.</td></tr>
  </table>
  </dd>
</dl>
<p>When the tree is empty a first node is constructed and the smart pointer to root-node is moved. Adding additional nodes is allowed via a the private member function add_node_recursive(std::pair&lt;const key, value&gt; p, node* current). It uses the functor for comparison and moves along the branches accordingly until a nullptr is encountered. If the key was not existing a new node is contructed and previous left or right smart pointer is moved to the new node. if the key was existing the value is overwritten. </p>

</div>
</div>
<a id="abc62eff481fddb7ed8511acf783502a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc62eff481fddb7ed8511acf783502a1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key , class value , class comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt; &amp; <a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>bst_rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">=bst_rhs</td><td><a class="el" href="class_b_s_t.html">BST</a> object to obtain ownership from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lhs&amp;</td><td>Reference to lhs <a class="el" href="class_b_s_t.html">BST</a> object.</td></tr>
  </table>
  </dd>
</dl>
<p>Takes rvalue reference &amp;&amp; and uses std::move() to obtain ownership over the rhs root-node. </p>

</div>
</div>
<a id="a51d840cd54ab6211c05c9d1b686ab5a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d840cd54ab6211c05c9d1b686ab5a4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key , class value , class comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt; &amp; <a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt; &amp;&#160;</td>
          <td class="paramname"><em>bst_rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">=bst_rhs</td><td><a class="el" href="class_b_s_t.html">BST</a> object to copy from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">lhs&amp;</td><td>Reference to lhs <a class="el" href="class_b_s_t.html">BST</a> object which is a deepcopy.</td></tr>
  </table>
  </dd>
</dl>
<p>First the copy assignement clears the lhs and proceeds like the copy constructor afterwards. It also contains a handling for self assignment. </p>

</div>
</div>
<a id="a71484110f50915eb23a1d6b5dccd753f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71484110f50915eb23a1d6b5dccd753f">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key , class value , class comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value &amp; <a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const key &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operator allowing value access via key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>target key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value&amp;</td><td>reference to the corresponding value.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_b_s_t.html#a981561762ee1793511d351735c1b60f3" title="Searches for a given key.">find()</a> is used to search and return the key. If the key can not be found a new key is inserted with value{} and returned. </p>

</div>
</div>
<a id="a309e1fe7dda03eff31910ae86b574fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309e1fe7dda03eff31910ae86b574fa5">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class key , class value , class comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const value &amp; <a class="el" href="class_b_s_t.html">BST</a>&lt; key, value, comparator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const key &amp;&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Const operator allowing value access via key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>target key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value&amp;</td><td>constant reference to the corresponding value.</td></tr>
  </table>
  </dd>
</dl>
<p><a class="el" href="class_b_s_t.html#a981561762ee1793511d351735c1b60f3" title="Searches for a given key.">find()</a> is also used for the const override. However if the key can not be found a std::runtime error is thrown. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>D:/PhD course SISSA-Physics and Chemistry of Biological Systems/Modules/Advanced Programming/Exam/C++/Class/Doxygen/<a class="el" href="_b_s_t_8h_source.html">BST.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
